package hw7;

public class Fraction {

	int numerator;
	int denominator;

	// constructor
	/**
	 * Create fraction with a given numerator and denominator and formats the
	 * negative fraction
	 * 
	 * @param numerator
	 * @param denominator
	 */

	public Fraction(int numerator, int denominator) {

		if ((numerator <= 0 && denominator > 0) || (numerator >= 0 && denominator < 0)) {
			this.numerator = -Math.abs(numerator);
			this.denominator = Math.abs(denominator);
		} else {
			// if the the numerator and denominator are both greater or smaller than 0
			// remove all the minus symbol
			this.numerator = Math.abs(numerator);
			this.denominator = Math.abs(denominator);
		}
	}

	/**
	 * 10/-15-->-10/15
	 */

	void formatNegativeFraction() {
		if (this.denominator < 0) {
			this.denominator *= -1;
			this.numerator *= -1;
		}
	}

	public int gcd(int num1, int num2) {

		// abs value
		if (num1 < 0) {
			num1 *= -1;
		}
		if (num2 < 0) {
			num2 *= -1;
		}

		if (num1 == 0) {
			return num2;
		} else {
			return gcd(num2, num1 % num2);
		}
	}

	public void reduceToLowestForm() {
		// set up the variable to store the biggest common factor
		int commonFactor = 1;
		// initialize instance variable, reducing 0 to 0/1
		if (this.numerator == 0) {
			this.denominator = 1;
		} else {
			// iterate over the possible common factors and take the value of the last one
			for (int i = 1; i <= Math.max(this.numerator, this.denominator); i++) {
				if (this.numerator % i == 0 && this.denominator % i == 0) {
					commonFactor = i;
				}
			}
			// divide both numerator and denominator by the biggest common factor
			this.numerator /= commonFactor;
			this.denominator /= commonFactor;
		}
	}

	public Fraction add(Fraction otherFraction) {
		// new
		Fraction theNewFractions = new Fraction(numerator, denominator);
		// numerator calculation
		theNewFractions.numerator = this.numerator * otherFraction.denominator
				+ this.denominator * otherFraction.numerator;
		// denominator calculation
		theNewFractions.denominator = this.denominator * otherFraction.denominator;
		// The returned Fractions2 must be in reduced/lowest form.
		theNewFractions.reduceToLowestForm();
		// Returns a new Fractions2 that is the sum of the two Fractions2s.
		return theNewFractions;
	}

	public Fraction subtract(Fraction otherFraction) {

		Fraction theNewFraction = new Fraction(numerator, denominator);
		theNewFraction.numerator = this.numerator * otherFraction.denominator
				- this.denominator * otherFraction.numerator;
		// denominator calculation
		theNewFraction.denominator = this.denominator * otherFraction.denominator;
		// The returned Fractions2 must be in reduced/lowest form.

		theNewFraction.reduceToLowestForm();

		return theNewFraction;
	}

	public Fraction mul(Fraction otherFraction) {

		this.reduceToLowestForm();
		otherFraction.reduceToLowestForm();

		int prodNumerator = this.numerator * otherFraction.numerator;
		int prodDenominator = this.denominator * otherFraction.denominator;

		Fraction newFraction = new Fraction(prodNumerator, prodDenominator);
		newFraction.reduceToLowestForm();
		return newFraction;
	}

	public Fraction div(Fraction otherFraction) {

		this.reduceToLowestForm();
		otherFraction.reduceToLowestForm();

		int otherNumerator = otherFraction.numerator;
		int otherDenominator = otherFraction.denominator;
		otherFraction.numerator = otherDenominator;
		otherFraction.denominator = otherNumerator;

		Fraction newFraction = this.mul(otherFraction);
		newFraction.reduceToLowestForm();

		return newFraction;
	}

	/***
	 * return fraction to decimal
	 * 
	 * @return
	 */
	public double decimal() {
		double doubleDenominator = (double) this.denominator;
		return this.numerator / doubleDenominator;
	}

	public void sqr() {
		Fraction otherFraction = new Fraction(this.numerator, this.denominator);
		Fraction newFraction = this.mul(otherFraction);
		this.numerator = newFraction.numerator;
		this.denominator = newFraction.denominator;
	}

	public Fraction average(Fraction otherFraction) {

		Fraction sumFractions = this.add(otherFraction);
		Fraction twoFractions = new Fraction(2, 1);
		Fraction divFraction = sumFractions.div(twoFractions);
		return divFraction;
	}

	public static Fraction average(Fraction[] fractions) {

		Fraction divFraction = new Fraction(0, 1);
		int numFractions = fractions.length;
		if (numFractions > 0) {
			Fraction sumFractions = fractions[0];
			for (int i = 1; i < numFractions; i++) {
				sumFractions = sumFractions.add(fractions[i]);
			}
			Fraction lenFraction = new Fraction(numFractions, 1);
			divFraction = sumFractions.div(lenFraction);
			divFraction.reduceToLowestForm();
		}
		return divFraction;
	}

	public static Fraction average(int[] ints) {

		Fraction divFraction = new Fraction(0, 1);
		int numInts = ints.length;

		if (numInts > 0) {
			int sumInts = ints[0];
			for (int i = 1; i < numInts; i++) {
				sumInts += ints[i];
			}
			divFraction = new Fraction(sumInts, numInts);
			divFraction.reduceToLowestForm();
		}
		return divFraction;
	}

	@Override
	public boolean equals(Object object) {
		if (!(object instanceof Fraction)) {
			return false;
		}
		Fraction thisFraction = new Fraction(this.numerator, this.denominator);
		thisFraction.reduceToLowestForm();

		Fraction otherFraction = (Fraction) object;
		otherFraction = new Fraction(otherFraction.numerator, otherFraction.denominator);
		otherFraction.reduceToLowestForm();

		return (thisFraction.numerator == otherFraction.numerator
				&& thisFraction.denominator == otherFraction.denominator);
	}

	@Override
	public String toString() {

		return this.numerator + "/" + this.denominator;
	}

	int findLeastCommonMultiple(int num1, int num2) {
		int lcm = 0;
		// abs value
		if (num1 < 0) {
			num1 *= -1;
		}
		if (num2 < 0) {
			num2 *= -1;
		}

		if ((num1 > num2) && (num1 % num2 == 0)) {
			lcm = num1;
		} else if ((num2 > num1) && (num2 % num1 == 0)) {
			lcm = num2;
		} else {
			lcm = num1 * num2;
		}
		return lcm;
	}

	int findGreatCommonMultiple(int num1, int num2) {
		int gcf = 0;
		// abs value
		if (num1 < 0) {
			num1 *= -1;
		}
		if (num2 < 0) {
			num2 *= -1;
		}

		if (num2 == 0)
			return num1;
		return findGreatCommonMultiple(num2, num1 % num2);

	}
}
